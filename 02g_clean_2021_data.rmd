---
title: "ENDIG: clean 2021 data"
author: "Nils Tjaden"
date: "`r Sys.Date()`"
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../documentation") })
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# move knitr working directory up by one level so it's the same as
# the on of the R Project 
knitr::opts_knit$set(root.dir = '../') 
```

This script cleans the 2021 ECDC surveillance system data, turning the xlsx file into a collection of sf-compatible objects.

## Setup

Load necessary packages:
  
-   `readxl` tidyverse package for reading data from Office Open XML spreadsheet files
-   `dplyr` for general-purpose data-wrangling
-   `tidyr` for general-purpose data-wrangling
-   `stringr` for manipulating strings
-   `sf` for handling of spatial polygon data

```{r, message=FALSE}
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(sf)
```

## Read data

### Disease meta data

Load the main meta data file:
  
```{r}
load(file = file.path("./data/processed/meta.rds"))
head(meta)
```

Extract disease names:
  
```{r}
disease_IDs <- meta %>% select(ID_master, ID_ECDC_2021)
disease_IDs
```

### EU countries

List of all EU (and non-EU) countries appearing in the data:
  
```{r}
load(file = file.path("./data/processed/countries.rds"))
countries
```

Note that these are 31 instead of the expected 27 countries. The list additionally includes: Iceland, Liechtenstein, Norway, United Kingdom. As of 2021, the UK is still on the list for Creutzfeldt-Jacob Disease (VCJD), but does not report anything else to ECDC.

### Country polygons

Load previously downloaded country polygons from NaturalEarth:
  
```{r}
load(file = file.path("./data/processed/countries_sf.rds"))
```

## Extract surveillance system characteristics per country

### General info

Extract the actual surveillance system data from the 2021 ECDC Excel file. This data has one data sheet per disease with columns for different aspects/characteristics (e.g. active vs. passive monitoring) of the surveillance systems and rows for countries. We need to reshape this, so that there is one data set per characteristic with a full list of countries and each column referring to one disease.

Columns B contains the countries, columns D to G contain the data. The first relevant column classifies surveillance systems as

-   Cp = compulsory
-   V = voluntary
-   O = other
-   . = [not classified]

The second relevant column classifies surveillance systems as:
  
  -   Co = comprehensive
-   Se = sentinel
-   O = other
-   . = [not classified]

This is followed by

-   A = active
-   P = passive
-   . = [not classified]

and

-   C = case-based
-   A = aggregated
-   . = [not classified]

We will convert these short forms into full words for easier identification as well as easier plotting (legends). We will also merge the "other" category with the undocumented "." category into a new "unspecified" category. The bulk of this can be done using `dplyr::recode()`, but the "." is difficult to match. `stringr::str_replace_all()` is helpful here.

### Process Data

```{r}
survtype_2021_compulsory <- data.frame(Country=countries)
survtype_2021_comprehensive <- data.frame(Country=countries)
survtype_2021_active <- data.frame(Country=countries)
survtype_2021_aggregated <- data.frame(Country=countries)

for (i in 1:nrow(disease_IDs)){ # iterate over all diseases
  dis <- as.character(disease_IDs[i,])
  
  # read data
  if(!is.na(dis[2])){
    # If there is a sheet for this disease in the 2021 workbook,
    # read the data for this disease:
    dat <-  readxl::read_xlsx(path = file.path(getwd(), "data/raw/Table-surveillance_systems_overview_2021.xlsx"),
                              skip = 2,
                              col_types = "text",
                              col_names = c("Country", "src", "compu", "compre", "act", "agg", "L", "P", "H", "O", "casedef"),
                              sheet = dis[2])
    if(nrow(dat) == 0){#if the sheet exists, but is empty, create a dummy
      dat <- data.frame(Country="dummy", compu="dummy", compre="dummy", act="dummy", agg="dummy")
    }
    # select relevant columns
    dat <- dat %>% select(Country, compu, compre, act, agg)
    
    # ECDC switched from using "Czech Republic" in earlier tables
    # to using "Czechia" at some point.
    # Harmonize that to "Czech Republic", if necessary
    dat$Country[which(dat$Country %in% "Czechia")] <- "Czech Republic"
    
    # some sheets have non-data rows at the bottom. Keep only rows that 
    # have a known country name in the first column. This also removes 
    # the dummy row created for empty tables.
    dat <- dat[which(dat$Country %in% countries),]
    
    # Handle multiple table rows per country
    dupe_countries <- unique(dat$Country[which(duplicated(dat$Country))])
    if(length(dupe_countries)>0){
      message(paste("duplicate country rows found in", dis[2], "sheet:"))
      
      # we'll need a proper data.frame for this:
      dat <- data.frame(dat)
      for(dupe_country in dupe_countries){
        cat("\ninput data:\n")
        dupe_rows <- which(dat$Country %in% dupe_country)
        sub <- dat[dupe_rows, ]
        print(sub)
        
        # Start with the assumption that rows for this country disagree in all 
        # columns, setting all columns to "." for unspecified.
        out <- c(dupe_country, rep(".", times=4))
        
        # if all rows of a column are identical, overwrite that spot in the
        # output row with the corresponding value (catching it from the first row of sub)
        if(length(unique(sub[,2]))==1){out[2] <- sub[1,2]}
        if(length(unique(sub[,3]))==1){out[3] <- sub[1,3]}
        if(length(unique(sub[,4]))==1){out[4] <- sub[1,4]}
        if(length(unique(sub[,5]))==1){out[5] <- sub[1,5]}
        
        # overwrite the first row for this country with the new data
        dat[dupe_rows[1],] <- out
        # remove the remaining rows for this country
        dat <- dat[-dupe_rows[2:length(dupe_rows)],]
        
        cat("\nturns to:\n")
        print(dat[dupe_rows[1],])
      }
      # convert back to a tibble
      dat <- as_tibble(dat)
    }
  }else{
    # if there is no sheet for this disease, just create an empty data.frame
    dat <- data.frame()
  }
  
  # clean data
  if(nrow(dat)==0){ 
    # If the whole table for this disease has no rows,
    # still add a column full of "no data".
    # Tables may have no rows because no sheet existed for this disease
    # (see above), or because an existing sheet was empty.
    filler <- data.frame(rep("no data", times=nrow(survtype_2021_compulsory)))
    names(filler) <- dis[1]
    survtype_2021_compulsory <- cbind(survtype_2021_compulsory, filler)
    survtype_2021_comprehensive <- cbind(survtype_2021_comprehensive, filler)
    survtype_2021_active <- cbind(survtype_2021_active, filler)
    survtype_2021_aggregated <- cbind(survtype_2021_aggregated, filler)
  }else{
    # otherwise do the cleanup routine:
    # recode the short categories into full words for easier
    # identification and plotting
    dat <- dat %>%
      mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ recode(.,
                      "Cp" = "compulsory",
                      "Co" = "comprehensive",
                      "Se" = "sentinel",
                      "V"  = "voluntary",
                      "O"  = "unspecified",
                      "C"  = "case-based",
                      "P"  = "passive"))
      ) %>% mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ str_replace_all(., fixed("."), "unspecified"))
      ) %>% mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ tidyr::replace_na(., "none"))
      )
    # "A" is used for different things in two columns,
    # we'll have tio do these separately:
    dat <- dat %>% mutate_at(vars(c("act")),
                             list(~recode(., "A" = "active"))) %>%
      mutate_at(vars(c("agg")),
                list(~recode(., "A" = "aggregated")))
    # put it all together
    dat2 <- dat %>% select(Country, compu) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2021_compulsory <- cbind(survtype_2021_compulsory, dat2[,2])
    
    dat2 <- dat %>% select(Country, compre)  %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2021_comprehensive <- cbind(survtype_2021_comprehensive, dat2[,2])
    
    dat2 <- dat %>% select(Country, act) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2021_active <- cbind(survtype_2021_active, dat2[,2])
    
    dat2 <- dat %>% select(Country, agg) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2021_aggregated <- cbind(survtype_2021_aggregated, dat2[,2])
  }
}
```

NA produced by countries not having a surveillance system for a disease still need to be turned into "none":
  
```{r}
survtype_2021_compulsory <- survtype_2021_compulsory %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2021_comprehensive <- survtype_2021_comprehensive %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2021_active <- survtype_2021_active %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2021_aggregated <- survtype_2021_aggregated %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
```

Turn classifications into factors of consistent order (none, good, OK, unknown) for easier plotting:
  
```{r}
survtype_2021_compulsory <- survtype_2021_compulsory %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "compulsory", "voluntary", "unspecified", "no data"))))
survtype_2021_comprehensive <- survtype_2021_comprehensive %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "comprehensive", "sentinel", "unspecified", "no data"))))
survtype_2021_active <- survtype_2021_active %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "active", "passive", "unspecified", "no data"))))
survtype_2021_aggregated <- survtype_2021_aggregated %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "case-based", "aggregated", "unspecified", "no data"))))

```

Export this data for further use elsewhere.

```{r}
saveRDS(survtype_2021_compulsory, file=file.path(getwd(), "data/processed/survtype_2021_compulsory.rds"))
saveRDS(survtype_2021_comprehensive, file=file.path(getwd(), "data/processed/survtype_2021_comprehensive.rds"))
saveRDS(survtype_2021_active, file=file.path(getwd(), "data/processed/survtype_2021_active.rds"))
saveRDS(survtype_2021_aggregated, file=file.path(getwd(), "data/processed/survtype_2021_aggregated.rds"))
```

## Spatialize and export

Now, get an object that contains all the countries for which ECDC has data and join it with the surveillance system information

```{r}
countries_2021_compulsory <- countries_sf %>% left_join(survtype_2021_compulsory, by=c("name_long" = "Country"))
countries_2021_comprehensive <- countries_sf %>% left_join(survtype_2021_comprehensive, by=c("name_long" = "Country"))
countries_2021_active <- countries_sf %>% left_join(survtype_2021_active, by=c("name_long" = "Country"))
countries_2021_aggregated <- countries_sf %>% left_join(survtype_2021_aggregated, by=c("name_long" = "Country"))
```

Export this data for further use elsewhere.

```{r}
saveRDS(countries_2021_compulsory, file=file.path(getwd(), "data/processed/countries_2021_compulsory.rds"))
saveRDS(countries_2021_comprehensive, file=file.path(getwd(), "data/processed/countries_2021_comprehensive.rds"))
saveRDS(countries_2021_active, file=file.path(getwd(), "data/processed/countries_2021_active.rds"))
saveRDS(countries_2021_aggregated, file=file.path(getwd(), "data/processed/countries_2021_aggregated.rds"))
```
