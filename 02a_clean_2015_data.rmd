---
colmuns---
title: "ENDIG: clean 2015 data"
author: "Nils Tjaden"
date: "`r Sys.Date()`"
output: html_document
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile, encoding = encoding, output_dir = "../documentation") })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
# move knitr working directory up by one level so it's the same as
# the on of the R Project 
knitr::opts_knit$set(root.dir = '../') 
```

This script cleans the 2015 ECDC surveillance system data, turning the xlsx file into a collection of sf-compatible objects.

## Setup

Load necessary packages:

-   `readxl` tidyverse package for reading data from Office Open XML spreadsheet files
-   `dplyr` for general-purpose data-wrangling
-   `tidyr` for general-purpose data-wrangling
-   `stringr` for manipulating strings
-   `sf` for handling of spatial polygon data

```{r, message=FALSE}
library(readxl)
library(dplyr)
library(tidyr)
library(stringr)
library(sf)
```

## Read data

### Disease meta data

Load the main meta data file:

```{r}
load(file = file.path("./data/processed/meta.rds"))
head(meta)
```

Extract disease names:

```{r}
disease_IDs <- meta %>% select(ID_master, ID_ECDC_2015)
disease_IDs
```

### EU countries

List of all EU (and non-EU) countries appearing in the data:

```{r}
load(file = file.path("./data/processed/countries.rds"))
countries
```

Note that these are 31 instead of the expected 27 countries. The list additionally includes: Iceland, Liechtenstein, Norway, United Kingdom. As of 2015, the UK is still on the list for Creutzfeldt-Jacob Disease (VCJD), but does not report anything else to ECDC.

### Country polygons

Load previously downloaded country polygons from NaturalEarth:

```{r}
load(file = file.path("./data/processed/countries_sf.rds"))
```

## Extract surveillance system characteristics per country

### General info

Extract the actual surveillance system data from the 2015 ECDC Excel file. This data has one data sheet per disease with columns for different aspects/characteristics (e.g. active vs. passive monitoring) of the surveillance systems and rows for countries. We need to reshape this, so that there is one data set per characteristic with a full list of countries and each column referring to one disease.

Columns B contains the countries, columns D to G contain the data. The first relevant column classifies surveillance systems as

-   Cp = compulsory
-   V = voluntary
-   O = other
-   . = [not classified]

The second relevant column classifies surveillance systems as:

-   Co = comprehensive
-   Se = sentinel
-   O = other
-   . = [not classified]

This is followed by

-   A = active
-   P = passive
-   . = [not classified]

and

-   C = case-based
-   A = aggregated
-   . = [not classified]

We will convert these short forms into full words for easier identification as well as easier plotting (legends). We will also merge the "other" category with the undocumented "." category into a new "unspecified" category. The bulk of this can be done using `dplyr::recode()`, but the "." is difficult to match. `stringr::str_replace_all()` is helpful here.

### Special treatment notes 2015

The *HIV and AIDS* sheet has a different layout, with two separate tables for HIV and AIDS respectively.The *HIV and AIDS* sheet has a different layout, with two separate tables for HIV and AIDS respectively. *Hep B* and *Hep C* are missing a column. Otherwise see console output below.

### Process Data

```{r}
survtype_2015_compulsory <- data.frame(Country=countries)
survtype_2015_comprehensive <- data.frame(Country=countries)
survtype_2015_active <- data.frame(Country=countries)
survtype_2015_aggregated <- data.frame(Country=countries)

for (i in 1:nrow(disease_IDs)){ # iterate over all diseases
  dis <- as.character(disease_IDs[i,])
  
  #HIV/AIDs has a completely different layout
  if(!dis[2] %in% "HIV and AIDS"){
    # read data
    if(!is.na(dis[2])){
      # If there is a sheet for this disease in the 2015 workbook,
      # read the data for this disease:
      
      if(!dis[2] %in% c("Hep B", "Hep C")){
      dat <-  readxl::read_xlsx(path = file.path(getwd(), "data/raw/Table-surveillance_systems_overview_2015.xlsx"),
                                skip = 5,
                                col_types = "text",
                                col_names = c("Country", "src", "compu", "compre", "act", "agg", "L", "P", "H", "O", "casedef"),
                                sheet = dis[2])
      }else{# add missing "act" and "compu" column to HEPB and HEPC
        dat <-  readxl::read_xlsx(path = file.path(getwd(), "data/raw/Table-surveillance_systems_overview_2015.xlsx"),
                                skip = 5,
                                col_types = "text",
                                col_names = c("Country", "src", "coverage", "compre", "agg", "L", "P", "H", "O", "casedef"),
                                sheet = dis[2])
        dat$act <- "."
        dat$compu <- "."
      }
 
      # select relevant columns
      dat <- dat %>% select(Country, compu, compre, act, agg)

      # ECDC switched from using "Czech Republic" in earlier tables
      # to using "Czechia" at some point.
      # Harmonize that to "Czech Republic", if necessary
      dat$Country[which(dat$Country %in% "Czechia")] <- "Czech Republic"
      
      # These sheets have non-data rows at the bottom. Keep only rows that 
      # have a known country name in the first column:
      dat <- dat[which(dat$Country %in% countries),]
      
      # Handle multiple table rows per country
      dupe_countries <- unique(dat$Country[which(duplicated(dat$Country))])
      if(length(dupe_countries)>0){
        message(paste("duplicate country rows found in", dis[2], "sheet:"))
        
        # we'll need a proper data.frame for this:
        dat <- data.frame(dat)
        for(dupe_country in dupe_countries){
          cat("\ninput data:\n")
          dupe_rows <- which(dat$Country %in% dupe_country)
          sub <- dat[dupe_rows, ]
          print(sub)
          
          # Start with the assumption that rows for this country disagree in all 
          # columns, setting all columns to "." for unspecified.
          out <- c(dupe_country, rep(".", times=4))
          
          # if all rows of a column are identical, overwrite that spot in the
          # output row with the corresponding value (catching it from the first row of sub)
          if(length(unique(sub[,2]))==1){out[2] <- sub[1,2]}
          if(length(unique(sub[,3]))==1){out[3] <- sub[1,3]}
          if(length(unique(sub[,4]))==1){out[4] <- sub[1,4]}
          if(length(unique(sub[,5]))==1){out[5] <- sub[1,5]}
          
          # overwrite the first row for this country with the new data
          dat[dupe_rows[1],] <- out
          # remove the remaining rows for this country
          dat <- dat[-dupe_rows[2:length(dupe_rows)],]
          
          cat("\nturns to:\n")
          print(dat[dupe_rows[1],])
        }
        # convert back to a tibble
        dat <- as_tibble(dat)
      }
    }else{
      # if there is no sheet for this disease, just create an empty data.frame
      dat <- data.frame()
    }
  }else{
  # Special treatment for HIV/AIDS sheet starts here  
    dat <-  readxl::read_xlsx(path = file.path(getwd(), "data/raw/Table-surveillance_systems_overview_2015.xlsx"),
                               range = "A5:K36",
                               sheet = dis[2])
    
    # dissect the two sub-tables in the sheet
    dat1 <- dat[, c(1, 4, 5)]
    names(dat1) <- c("Country", "compu", "compre")
    dat2 <- dat[, c(7, 10, 11)]
    names(dat2) <- c("Country", "compu", "compre")
    # and put them back together as a single table
    dat <- rbind(dat1, dat2)
    
    # There are no columns for active/passive nor aggregated/case-based
    # Add them, treating them as unspecified
    dat$act <- "."
    dat$agg <- "."
    
    # encoding for "unknown/unspecified" in inconsistent with the other diseases
    # replace with the standard "."
    dat$compre[dat$compre %in% "Not specified/unknown"] <- "."
    
    # encoding for compulsory vs. voluntary uses "C" instead of "Cp"
    # fix that to avoid misclassifications downstream
    dat$compu[dat$compu %in% "C"] <- "Cp"
    
    # ECDC switched from using "Czech Republic" in earlier tables
    # to using "Czechia" at some point.
    # Harmonize that to "Czechia", if necessary
    dat$Country[which(dat$Country %in% "Czech Republic")] <- "Czechia"

    # There are now two rows per country. Handle them in the same way
    # as multiple table rows per country are being handled
      dupe_countries <- unique(dat$Country[which(duplicated(dat$Country))])
      if(length(dupe_countries)>0){
        message(paste("duplicate country rows found in", dis[2], "sheet:"))
        
        # we'll need a proper data.frame for this:
        dat <- data.frame(dat)
        for(dupe_country in dupe_countries){
          cat("\ninput data:\n")
          dupe_rows <- which(dat$Country %in% dupe_country)
          sub <- dat[dupe_rows, ]
          print(sub)
          
          # Start with the assumption that rows for this country disagree in all 
          # columns, setting all columns to "." for unspecified.
          out <- c(dupe_country, rep(".", times=4))
          
          # if all rows of a column are identical, overwrite that spot in the
          # output row with the corresponding value (catching it from the first row of sub)
          if(length(unique(sub[,2]))==1){out[2] <- sub[1,2]}
          if(length(unique(sub[,3]))==1){out[3] <- sub[1,3]}
          if(length(unique(sub[,4]))==1){out[4] <- sub[1,4]}
          if(length(unique(sub[,5]))==1){out[5] <- sub[1,5]}
          
          # overwrite the first row for this country with the new data
          dat[dupe_rows[1],] <- out
          # remove the remaining rows for this country
          dat <- dat[-dupe_rows[2:length(dupe_rows)],]
          
          cat("\nturns to:\n")
          print(dat[dupe_rows[1],])
        }
        # convert back to a tibble
        dat <- as_tibble(dat)
      }
  }
  
  # clean data
  if(nrow(dat)==0){ 
    # If the whole table for this disease has no rows,
    # still add a column full of "no data".
    # Tables may have no rows because no sheet existed for this disease
    # (see above), or because an existing sheet was empty.
    filler <- data.frame(rep("no data", times=nrow(survtype_2015_compulsory)))
    names(filler) <- dis[1]
    survtype_2015_compulsory <- cbind(survtype_2015_compulsory, filler)
    survtype_2015_comprehensive <- cbind(survtype_2015_comprehensive, filler)
    survtype_2015_active <- cbind(survtype_2015_active, filler)
    survtype_2015_aggregated <- cbind(survtype_2015_aggregated, filler)
  }else{
    # otherwise do the cleanup routine:
    # recode the short categories into full words for easier
    # identification and plotting
    dat <- dat %>%
      mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ recode(.,
                      "Cp" = "compulsory",
                      "Co" = "comprehensive",
                      "Se" = "sentinel",
                      "V"  = "voluntary",
                      "O"  = "unspecified",
                      "C"  = "case-based",
                      "P"  = "passive"))
      ) %>% mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ str_replace_all(., fixed("."), "unspecified"))
      ) %>% mutate_at(
        vars(c("compu", "compre", "act", "agg")),
        list(~ tidyr::replace_na(., "none"))
      )
    # "A" is used for different things in two columns,
    # we'll have to do these separately:
    dat <- dat %>% mutate_at(vars(c("act")),
                             list(~recode(., "A" = "active"))) %>%
      mutate_at(vars(c("agg")),
                    list(~recode(., "A" = "aggregated")))
    # put it all together
    dat2 <- dat %>% select(Country, compu) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2015_compulsory <- cbind(survtype_2015_compulsory, dat2[,2])
    
    dat2 <- dat %>% select(Country, compre)  %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2015_comprehensive <- cbind(survtype_2015_comprehensive, dat2[,2])
    
    dat2 <- dat %>% select(Country, act) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2015_active <- cbind(survtype_2015_active, dat2[,2])
    
    dat2 <- dat %>% select(Country, agg) %>%
      right_join(data.frame(Country=countries), by="Country")
    names(dat2)[2] <- dis[1]
    dat2 <- arrange(dat2, Country)
    survtype_2015_aggregated <- cbind(survtype_2015_aggregated, dat2[,2])
  }
}
```

NA produced by countries not having a surveillance system for a disease still need to be turned into "none":

```{r}
survtype_2015_compulsory <- survtype_2015_compulsory %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2015_comprehensive <- survtype_2015_comprehensive %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2015_active <- survtype_2015_active %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
survtype_2015_aggregated <- survtype_2015_aggregated %>%
  mutate_all(list(~ tidyr::replace_na(., "none"))) 
```

Turn classifications into factors of consistent order (none, good, OK, unknown) for easier plotting:

```{r}
survtype_2015_compulsory <- survtype_2015_compulsory %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "compulsory", "voluntary", "unspecified", "no data"))))
survtype_2015_comprehensive <- survtype_2015_comprehensive %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "comprehensive", "sentinel", "unspecified", "no data"))))
survtype_2015_active <- survtype_2015_active %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "active", "passive", "unspecified", "no data"))))
survtype_2015_aggregated <- survtype_2015_aggregated %>%
  mutate(across(!1, ~factor(.x, levels=c("none", "case-based", "aggregated", "unspecified", "no data"))))

```

Export this data for further use elsewhere.

```{r}
saveRDS(survtype_2015_compulsory, file=file.path(getwd(), "data/processed/survtype_2015_compulsory.rds"))
saveRDS(survtype_2015_comprehensive, file=file.path(getwd(), "data/processed/survtype_2015_comprehensive.rds"))
saveRDS(survtype_2015_active, file=file.path(getwd(), "data/processed/survtype_2015_active.rds"))
saveRDS(survtype_2015_aggregated, file=file.path(getwd(), "data/processed/survtype_2015_aggregated.rds"))
```

## Spatialize and export

Now, get an object that contains all the countries for which ECDC has data and join it with the surveillance system information

```{r}
countries_2015_compulsory <- countries_sf %>% left_join(survtype_2015_compulsory, by=c("name_long" = "Country"))
countries_2015_comprehensive <- countries_sf %>% left_join(survtype_2015_comprehensive, by=c("name_long" = "Country"))
countries_2015_active <- countries_sf %>% left_join(survtype_2015_active, by=c("name_long" = "Country"))
countries_2015_aggregated <- countries_sf %>% left_join(survtype_2015_aggregated, by=c("name_long" = "Country"))
```

Export this data for further use elsewhere.

```{r}
saveRDS(countries_2015_compulsory, file=file.path(getwd(), "data/processed/countries_2015_compulsory.rds"))
saveRDS(countries_2015_comprehensive, file=file.path(getwd(), "data/processed/countries_2015_comprehensive.rds"))
saveRDS(countries_2015_active, file=file.path(getwd(), "data/processed/countries_2015_active.rds"))
saveRDS(countries_2015_aggregated, file=file.path(getwd(), "data/processed/countries_2015_aggregated.rds"))
```
